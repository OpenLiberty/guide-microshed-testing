//  Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microshed-testing
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-releasedate: 2019-11-04
:page-guide-category: microprofile
:page-essential: true
:page-essential-order: 1
:page-description: Learn how to test a MicroProfile or Jakarta EE application using MicroShed Testing.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Java EE', 'Jakarta EE', 'Testing']
:page-related-guides: ['rest-intro', 'docker', 'rest-client-java']
:page-permalink: /guides/{projectid}
:repo-description: Visit the https://openliberty.io/guides/{projectid}.html[website] for the rendered version of the guide.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
= Testing a MicroProfile or Jakarta EE application

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to test a MicroProfile or Jakarta EE application using MicroShed Testing.

== What you'll learn

You will start with an existing REST application that runs on OpenLiberty, and use https://microshed.org/microshed-testing/[MicroShed Testing] 
to write tests for the application that will exercise the application inside of a Docker container.

Often times tests may pass in dev/test environments, but fail in production because the application is
running differently in production than it is in dev/test. Luckily, we can greatly minimize these dev/prod
parity issues by testing our application as it runs in the same Docker container we'll be using in production.

=== What is Docker?

Docker is a tool that you can use to deploy and run applications with containers. You
can think of Docker like a virtual machine that runs various applications. However, unlike a typical virtual
machine, you can run these applications simultaneously on a single system and independent of
one another.

Learn more about Docker on the https://www.docker.com/what-docker[official Docker page^].

Learn how to install Docker on the https://docs.docker.com/engine/installation[official instructions page^].

[role="command"]
include::{common-includes}/gitclone.adoc[]

=== Try what you'll build

The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

First, look at `PersonServiceIT` to see what the tests look like:

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/src/test/java/io/openliberty/guides/testing/PersonServiceIT.java[]
----

To try out the application, first go to the `finish` directory and run the following Maven 
goal to build the application and run the integration tests on an Open Liberty server in a container:
[role='command']
```
mvn verify
```

This may take some time on the first run, due to downloading dependencies and the Docker image for Open Liberty. If you 
re-run the same command again, it will be faster.

In addition to running integration tests from a cold start, you can use MicroShed Testing to run your tests on
an already running Open Liberty server, using Open Liberty's Dev Mode:

[role='command']
```
mvn liberty:dev
```

Once the Liberty server starts and you see the message `Press the Enter key to run tests on demand.`, you can press the 
enter key to run the integration tests. Once the tests finish, you can press the Enter key to run the tests again, or you 
can make code changes to the application or tests in between re-running the tests. Dev Mode will automatically
recompile and update any application or test code changes that you make.

After you are done running tests in dev mode, stop the Open Liberty server by pressing `CTRL+C`
in the shell session where you ran the server.

== Bootstrapping your application for testing

Navigate to the `start` directory to begin.

Start Open Liberty in development mode, which starts the Open Liberty server and listens 
for file changes:

[role="command"]
```
mvn liberty:dev
```

Wait for the message `Press the Enter key to run tests on demand.`, and then press the `Enter` key to run the tests. You will see that 1 test is run:

[console]
----
[INFO] Running integration tests...
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running io.openliberty.guides.testing.PersonServiceIT
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.024 s - in io.openliberty.guides.testing.PersonServiceIT
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] Integration tests finished.
----

To begin, annotate the `src/test/java/io/openliberty/guides/testing/PersonServiceIT.java` class with the `@MicroShedTest` annotation. This will indicate that the test class uses MicroShed Testing.

[source, Java, linenums, role='code_column']
----
import org.microshed.testing.jupiter.MicroShedTest;

@MicroShedTest
public class PersonServiceIT {
----

Next, we will define some basic information that informs MicroShed Testing if and how it should start our applictaion runtime, and what URL path the application will be available at:

[source, Java, linenums, role='code_column']
----
import org.microshed.testing.testcontainers.MicroProfileApplication;
import org.testcontainers.junit.jupiter.Container;

@MicroShedTest
public class PersonServiceIT {

    @Container
    public static MicroProfileApplication app = new MicroProfileApplication()
                    .withAppContextRoot("/guide-microshed-testing")
                    .withReadinessPath("/health/ready");

}
----

The `withAppContextRoot(String)` method indicates what the base path of the application is. In this case, our application is deployed at http://localhost:9080/guide-microshed-testing, so the app context root is `/guide-microshed-testing`, which is the portion of the URL after the hostname and port.

The `withReadinessPath(String)` method indicates what path should be polled via HTTP to determine application readiness. MicroShed Testing will automatically start or discover the MicroProfileApplication and wait for it to be ready before the tests start running. In this case, we are utilizing the default application readiness check at http://localhost:9080/health/ready, which is provided by the `mpHealth-2.0` feature in our server.xml configuration. When the readiness URL returns HTTP 200, the application is considered ready and the tests will begin running.

Save your changes to `PersonServiceIT` and press `Enter` in your console window to re-run the tests. You will still see only 1 test running, but the output will be a bit different. Notice that MicroShed Testing is using a "hollow" configuration mode. This means it is re-using an existing application runtime for the test, and not starting up a new application instance each time you initiate a test run.

== Talking to your application with a REST client

With MicroShed Testing we exercise the application in a black-box fashion. This means the tests do not get to access internals of the application. Instead, we can only exercise the application from the "outside", most commonly with HTTP requests. To simplify the HTTP interactions, we can inject a REST client to our test like so:

[source, Java, role='code_column']
----
import javax.inject.Inject;

@MicroShedTest
public class PersonServiceIT {
    
    @Inject
    public static PersonService personSvc;
----

Here the injected type `PersonService` is the same `io.openliberty.guides.testing.PersonService` class that is used in our actual application. However, the _instance_ that gets injected is a REST client proxy. So if we call `personSvc.createPerson("Bob", 42)`, what actually happens is the REST client makes an HTTP POST request to the running application at http://localhost:9080/guide-microshed-testing/people/ which triggers the corresponding Java method in the application.

== Writing your first test

Now that the setup is complete, we can write our first test case. We will start by testing the basic "create person" use case for our REST-based application. To do this, we use the REST client injected by MicroShed Testing to make the HTTP POST request to our application and read the response:

[source, Java, role='code_column']
----
import static org.junit.jupiter.api.Assertions.assertNotNull;

@MicroShedTest
public class PersonServiceIT {

    // ...
    
    @Inject
    public static PersonService personSvc;
    
    @Test
    public void testCreatePerson() {
        Long createId = personSvc.createPerson("Hank", 42);
        assertNotNull(createId);
    }
}
----

Add the above code to `src/test/java/io/openliberty/guides/testing/PersonServiceIT.java` and save the changes. Then, press `Enter` in your console window to run the test. You will see that the test ran again and this time exercised the REST endpoint of your application, including the response of your application's endpoint.

[console]
----
INFO org.microshed.testing.jaxrs.RestClientBuilder  - Building rest client for class io.openliberty.guides.testing.PersonService with base path: http://localhost:9080/guide-microshed-testing/ and providers: [class org.microshed.testing.jaxrs.JsonBProvider]
INFO org.microshed.testing.jaxrs.JsonBProvider  - Response from server: 1809686877352335426
----

== Testing outside of Dev Mode

Running the tests against a pre-started Liberty server is very conveneint for local development, but this may be tedous to set up in non-dev scenarios such as a CI/CD pipeline. For this reason, MicroShed Testing is also capable of starting and stopping the application runtime before and after the tests are executed. This is primarily accomplished using Docker and Testcontainers.

To test ousdie of Dev Mode, first exit Dev Mode by pressing `CTRL+C`.

Next, run the tests from a "cold start" by running the command:
[role='command']
```
mvn verify
```

Running tests from a cold start will take a little longer than running the tests from Dev Mode, since the application runtime needs to be started each time. However, the benefits of this mode are:

- A clean instance is used on each test run, for consistent results
- Automatically hooks into many existing build pipelines that are set up to run the `integration-test` phase

== Sharing configuration across multiple classes

Typically projects have multiple test classes that all exercise the same type of application deployment. For these cases it is useful to re-use existing configuration and application lifecycle across multiple test classes.

First, create another test class that has the same `@Container` configuration as the existing `PersonServiceIT` class.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `ErrorPathIT` class.#
`src/test/java/io/openliberty/guides/testing/ErrorPathIT.java`
----

ErrorPathIT.java
[source, java, linenums, role='code_column']
----
package io.openliberty.guides.testing;

import static org.junit.jupiter.api.Assertions.assertThrows;

import javax.inject.Inject;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.NotFoundException;

import org.junit.jupiter.api.Test;
import org.microshed.testing.jupiter.MicroShedTest;
import org.microshed.testing.testcontainers.MicroProfileApplication;
import org.testcontainers.junit.jupiter.Container;

@MicroShedTest
public class ErrorPathIT {
    
    @Container
    public static MicroProfileApplication app = new MicroProfileApplication()
                    .withAppContextRoot("/guide-microshed-testing")
                    .withReadinessPath("/health/ready");
    
    @Inject
    public static PersonService personSvc;
    
    @Test
    public void testGetUnknownPerson() {
        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));
    }

    @Test
    public void testCreateBadPersonNullName() {
        assertThrows(BadRequestException.class, () -> personSvc.createPerson(null, 5));
    }

    @Test
    public void testCreateBadPersonNegativeAge() {
        assertThrows(BadRequestException.class, () -> personSvc.createPerson("NegativeAgePersoN", -1));
    }

    @Test
    public void testCreateBadPersonNameTooLong() {
        assertThrows(BadRequestException.class, () -> personSvc.createPerson("NameTooLongPersonNameTooLongPersonNameTooLongPerson", 5));
    }
}
----

Now, run the tests again outside of Dev Mode:
[role='command']
```
mvn verify
```

You will notice that tests for both classes (`PersonServiceIT` and `ErrorPathIT`) are run, but a new server is started for each test class, resulting in a longer test runtime.

To solve this issue, common configuration can be placed in a class that implements `SharedContainerConfiguration`.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `AppDeploymentConfig` class.#
`src/test/java/io/openliberty/guides/testing/AppDeploymentConfig.java`
----

AppDeploymentConfig.java
[source, java, linenums, role='code_column']
----
include::finish/src/test/java/io/openliberty/guides/testing/AppDeploymentConfig.java[]
----

Once the common configuration is created, the test classes can be updated to reference this shared configuration.

Remove the following code from `PersonServiceIT.java` and `ErrorPathIT.java`:

[source, Java, role='code_column']
----
@Container
public static MicroProfileApplication app = new MicroProfileApplication()
                .withAppContextRoot("/guide-microshed-testing")
                .withReadinessPath("/health/ready");
----

Then, annotate each test class with `@SharedContainerConfiguration` referencing the shared configuration class.

[source, Java, role='code_column']
----
import org.microshed.testing.SharedContainerConfig;

@MicroShedTest
@SharedContainerConfig(AppDeploymentConfig.class)
public class PersonServiceIT {
----

[source, Java, role='code_column']
----
import org.microshed.testing.SharedContainerConfig;

@MicroShedTest
@SharedContainerConfig(AppDeploymentConfig.class)
public class ErrorPathIT {
----

Now, if you re-run the tests, they will run in about half the time because the same server instance is being used for both test classes.
[role='command']
```
mvn verify
```

== Great work! You're done!

You developed automated tests for a REST service in Open Liberty by using MicroShed Testing and Liberty Dev Mode.

== Related Links

Learn more about MicroShed Testing.

https://microshed.org/microshed-testing/[View the MicroShed Testing website^]

include::{common-includes}/attribution.adoc[subs="attributes"]
